"""
DraftEngine - Handles all draft-related operations including CRUD and book export.
"""
from db import get_db
import uuid
import json
from datetime import datetime


class DraftEngine:
    def __init__(self):
        pass

    def create_draft(self, title, content, status='draft', evidence_ids=None):
        """Create a new draft with optional evidence links."""
        draft_id = f"DFT_{uuid.uuid4().hex[:8]}"
        evidence_ids = evidence_ids or []
        
        conn = get_db()
        try:
            conn.execute(
                "INSERT INTO drafts (id, title, content_json, status, created_at, updated_at) VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))",
                (draft_id, title, json.dumps({'content': content}), status)
            )
            
            for mid in evidence_ids:
                conn.execute("INSERT INTO draft_evidence (draft_id, message_id) VALUES (?, ?)", (draft_id, mid))
                
            conn.execute("INSERT INTO activity_log (id, event_type, description, metadata_json) VALUES (?, ?, ?, ?)",
                (f"ACT_{uuid.uuid4().hex[:8]}", 'draft', f"Created draft: {title}", json.dumps({'draft_id': draft_id}))
            )
            
            conn.commit()
            return {'success': True, 'id': draft_id}
        except Exception as e:
            conn.rollback()
            raise
        finally:
            conn.close()

    def get_draft(self, draft_id):
        """Get draft by ID with evidence."""
        conn = get_db()
        draft = conn.execute("SELECT * FROM drafts WHERE id=?", (draft_id,)).fetchone()
        
        if not draft:
            conn.close()
            return None
            
        evidence = conn.execute("""
            SELECT m.* 
            FROM messages m
            JOIN draft_evidence de ON de.message_id = m.id
            WHERE de.draft_id = ?
        """, (draft_id,)).fetchall()
        
        conn.close()
        
        d_dict = dict(draft)
        try:
            content_obj = json.loads(d_dict['content_json'])
            d_dict['content'] = content_obj.get('content', '')
        except:
            d_dict['content'] = ""
            
        d_dict['evidence'] = [dict(m) for m in evidence]
        return d_dict

    def update_draft(self, draft_id, title=None, content=None, status=None, evidence_ids=None):
        """Update draft fields."""
        conn = get_db()
        try:
            fields = []
            params = []
            if title is not None:
                fields.append("title = ?")
                params.append(title)
            if content is not None:
                fields.append("content_json = ?")
                params.append(json.dumps({'content': content}))
            if status is not None:
                fields.append("status = ?")
                params.append(status)
                
            if fields:
                fields.append("updated_at = datetime('now')")
                sql = f"UPDATE drafts SET {', '.join(fields)} WHERE id = ?"
                params.append(draft_id)
                conn.execute(sql, params)
                
            if evidence_ids is not None:
                conn.execute("DELETE FROM draft_evidence WHERE draft_id = ?", (draft_id,))
                for mid in evidence_ids:
                    conn.execute("INSERT INTO draft_evidence (draft_id, message_id) VALUES (?, ?)", (draft_id, mid))
                    
            conn.execute("INSERT INTO activity_log (id, event_type, description, metadata_json) VALUES (?, ?, ?, ?)",
                (f"ACT_{uuid.uuid4().hex[:8]}", 'draft', f"Updated draft: {title or draft_id}", json.dumps({'draft_id': draft_id}))
            )
            conn.commit()
            return {'success': True}
        except Exception as e:
            conn.rollback()
            raise
        finally:
            conn.close()

    def export_book(self):
        """Export all chapters and scenes as markdown."""
        conn = get_db()
        chapters = conn.execute("SELECT * FROM chapters ORDER BY order_index").fetchall()
        
        full_text = "# Autobiography\\n\\nGenerated by Autobiography Engine\\n\\n"
        
        for ch in chapters:
            full_text += f"# {ch['title']}\\n\\n"
            if ch['content_markdown']:
                full_text += f"{ch['content_markdown']}\\n\\n"
                
            scenes = conn.execute("SELECT * FROM scenes WHERE chapter_id = ? ORDER BY id", (ch['id'],)).fetchall()
            for sc in scenes:
                full_text += f"## Scene: {sc['title']}\\n\\n"
                if sc['notes']:
                    full_text += f"> NOTE: {sc['notes']}\\n\\n"
                    
            full_text += "---\\n\\n"
            
        conn.close()
        return full_text

    def list_chapters(self):
        """List all chapters."""
        conn = get_db()
        rows = conn.execute("SELECT * FROM chapters ORDER BY order_index").fetchall()
        conn.close()
        return [dict(r) for r in rows]

    def create_chapter(self, title, index=0):
        """Create a new chapter."""
        chapter_id = f"CHP_{uuid.uuid4().hex[:8]}"
        conn = get_db()
        conn.execute("INSERT INTO chapters (id, title, order_index, content_markdown) VALUES (?, ?, ?, '')", (chapter_id, title, index))
        conn.commit()
        conn.close()
        return {'success': True, 'id': chapter_id}

    def get_chapter(self, chapter_id):
        """Get chapter with scenes."""
        conn = get_db()
        chapter = conn.execute("SELECT * FROM chapters WHERE id=?", (chapter_id,)).fetchone()
        if not chapter:
            conn.close()
            return None
        scenes = conn.execute("SELECT * FROM scenes WHERE chapter_id=?", (chapter_id,)).fetchall()
        conn.close()
        return {'chapter': dict(chapter), 'scenes': [dict(s) for s in scenes]}

    def update_chapter(self, chapter_id, content=None, title=None):
        """Update chapter."""
        conn = get_db()
        if content is not None:
            conn.execute("UPDATE chapters SET content_markdown = ? WHERE id = ?", (content, chapter_id))
        if title is not None:
            conn.execute("UPDATE chapters SET title = ? WHERE id = ?", (title, chapter_id))
        conn.commit()
        conn.close()
        return {'success': True}

    def create_scene(self, chapter_id, title, event_id=None):
        """Create a new scene."""
        scene_id = f"SCN_{uuid.uuid4().hex[:8]}"
        conn = get_db()
        conn.execute("INSERT INTO scenes (id, chapter_id, title, event_id, notes) VALUES (?, ?, ?, ?, '')", (scene_id, chapter_id, title, event_id))
        conn.commit()
        conn.close()
        return {'success': True, 'id': scene_id}

    def list_arcs(self):
        """List all story arcs with events."""
        conn = get_db()
        arcs = conn.execute("SELECT * FROM story_arcs ORDER BY order_index").fetchall()
        result = []
        for arc in arcs:
            sql = """
            SELECT e.* 
            FROM events e
            JOIN arc_events ae ON ae.event_id = e.id
            WHERE ae.arc_id = ?
            ORDER BY e.start_date
            """
            events = conn.execute(sql, (arc['id'],)).fetchall()
            result.append({
                'id': arc['id'],
                'title': arc['title'],
                'description': arc['description'],
                'events': [dict(e) for e in events]
            })
        conn.close()
        return result

    def create_arc(self, title):
        """Create a new story arc."""
        arc_id = f"ARC_{uuid.uuid4().hex[:8]}"
        conn = get_db()
        conn.execute("INSERT INTO story_arcs (id, title, description) VALUES (?, ?, '')", (arc_id, title))
        conn.commit()
        conn.close()
        return {'success': True, 'id': arc_id}

    def assign_event_to_arc(self, event_id, arc_id=None):
        """Assign event to arc (1:1 relationship)."""
        conn = get_db()
        conn.execute("DELETE FROM arc_events WHERE event_id = ?", (event_id,))
        if arc_id:
            conn.execute("INSERT INTO arc_events (arc_id, event_id) VALUES (?, ?)", (arc_id, event_id))
        conn.commit()
        conn.close()
        return {'success': True}
